<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Alexa Lowry</title>

    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="css/one-page-wonder.css" rel="stylesheet">


</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#">LIS 2360 Web Application Development</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="#topic1">Highlight #1</a>
                    </li>
                    <li>
                        <a href="#topic2">Hightlight #2</a>
                    </li>
                    <li>
                        <a href="#topic3">Hightlight #3</a>
                    </li>
                    <li>
                        <a href="#topic4">Hightlight #4</a>
                    </li>
                    <li>
                        <a href="#topic5">Hightlight #5</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Full Width Image Header -->
    <header class="header-image">
        <div class="headline">
            <div class="container">
                <h2>Lesson 3 Highlights</h2>
                <h3>Alexa Lowry </h3>
            </div>
        </div>
    </header>

    <!-- Page Content -->
    <div class="container">

        <hr class="featurette-divider">

        <!-- First Featurette -->
        <div class="featurette" id="topic1">
            <img class="featurette-image img-circle img-responsive pull-right" src="images/version.jpg">
            <h2 class="featurette-heading">About Version Control
                <span class="text-muted">and CVCSs </span>
            </h2>
            <p class="lead">  Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. So for example, If you are a graphic or web designer and want to keep every version of an image or layout, a Version Control System (VCS) is a very wise thing to use. It allows you to revert selected files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead. In a way it is like how google docs constantly saves all the work you do and if you click the different save points you can see what exactly was changed at that point. One of the more popular VCS tools was a system called RCS, which is still distributed with many computers today. RCS works by keeping patch sets in a special format on disk; it can then re-create what any file looked like at any point in time by adding up all the patches. Centralized Version Control Systems (CVCSs) were developed to help people who wished to collaborate. In todays society we are constantly working with people al lover the world and need to be able to share our work in a way that is easy and lets others make corrections. These systems (such as CVS, Subversion, and Perforce) have a single server that contains all the versioned files, and a number of clients that check out files from that central place. For many years, this has been the standard for version control.  </p>
        </div>

        <hr class="featurette-divider">

        <!-- Second Featurette -->
        <div class="featurette" id="topic2">
            <img class="featurette-image img-circle img-responsive pull-left" src="images/git.jpg">
            <h2 class="featurette-heading">Git
                <span class="text-muted">The Basics</span>
            </h2>
            <p class="lead">The major difference between Git and any other VCS is the way Git thinks about its data. Conceptually, most other systems store information as a list of file-based changes. These other systems think of the information they store as a set of files and the changes made to each file over time Git doesn’t think of or store its data this way. Instead, Git thinks of its data more like a series of snapshots of a miniature filesystem.  With Git, every time you commit, or save the state of your project, Git basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot. To be efficient, if files have not changed, Git doesn’t store the file again, just a link to the previous identical file it has already stored. Git thinks about its data more like a stream of snapshots. Git has three main states that your files can reside in: committed, modified, and staged; Committed means that the data is safely stored in your local database. Modified means that you have changed the file but have not committed it to your database yet. Staged means that you have marked a modified file in its current version to go into your next commit snapshot. The basic Git workflow goes something like this: You modify files in your working tree. You selectively stage just those changes you want to be part of your next commit, which adds only those changes to the staging area. You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory. </p>
        </div>

        <hr class="featurette-divider">

        <!-- Third Featurette -->
        <div class="featurette" id="topic3">
            <img class="featurette-image img-circle img-responsive pull-right" src="images/gitrepo.jpg">
            <h2 class="featurette-heading">Git Repository
                <span class="text-muted"> </span>
            </h2>
            <p class="lead">You typically obtain a Git repository in one of two ways, You can take a local directory that is currently not under version control, and turn it into a Git repository, orYou can clone an existing Git repository from elsewhere.In either case, you end up with a Git repository on your local machine, ready for work. If you have a project directory that is currently not under version control and you want to start controlling it with Git, you first need to go to that project’s directory. If you’ve never done this, it looks a little different depending on which system you’re running. f you want to start version-controlling existing files (as opposed to an empty directory), you should probably begin tracking those files and do an initial commit. You can accomplish that with a few git add commands that specify the files you want to track, followed by a git commit. f you want to get a copy of an existing Git repository for example, a project you’d like to contribute to the command you need is git clone. If you’re familiar with other VCS systems such as Subversion, you’ll notice that the command is "clone" and not "checkout". This is an important distinction; instead of getting just a working copy, Git receives a full copy of nearly all data that the server has. Every version of every file for the history of the project is pulled down by default when you run git clone. In fact, if your server disk gets corrupted, you can often use nearly any of the clones on any client to set the server back to the state it was in when it was cloned (you may lose some server-side hooks and such, but all the versioned data would be there.</p>
        </div>
        
        <hr class="featurette-divider">
        
       <!-- Fourth Featurette -->
        <div class="featurette" id="topic4">
            <img class="featurette-image img-circle img-responsive pull-left" src="images/lifecycle.jpg">
            <h2 class="featurette-heading">Recording Changes
                <span class="text-muted">to the Repository</span>
            </h2>
            <p class="lead"> Typically, you’ll want to start making changes and committing snapshots of those changes into your repository each time the project reaches a state you want to record. Remember that each file in your working directory can be in one of two states: tracked or untracked. Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged. In short, tracked files are files that Git knows about. Untracked files are everything else - any files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of your files will be tracked and unmodified because Git just checked them out and you haven’t edited anything. As you edit files, Git sees them as modified, because you’ve changed them since your last commit. As you work, you selectively stage these modified files and then commit all those staged changes, and the cycle repeats. You can use a git status comand to determin what files are in what stages. To track new files you would use the git add command.  If you change a previously tracked file called CONTRIBUTING.md and then run your git status command again. </p>
        </div>

        <hr class="featurette-divider">

        <!-- Fifth Featurette -->
        <div class="featurette" id="topic5">
            <img class="featurette-image img-circle img-responsive pull-right" src="images/no.jpg">
            <h2 class="featurette-heading">A short history of
                <span class="text-muted">Git </span>
            </h2>
            <p class="lead"> Git does not = GitHub but before talking about that we should talk about where Git started. As with many great things in life, Git began with a bit of creative destruction and fiery controversy.The Linux kernel is an open source software project of fairly large scope. For most of the lifetime of the Linux kernel maintenance (1991–2002), changes to the software were passed around as patches and archived files. In 2002, the Linux kernel project began using a proprietary DVCS called BitKeeper.In 2005, the relationship between the community that developed the Linux kernel and the commercial company that developed BitKeeper broke down, and the tool’s free-of-charge status was revoked. This prompted the Linux development community (and in particular Linus Torvalds, the creator of Linux) to develop their own tool based on some of the lessons they learned while using BitKeeper. Some of the goals of the new system were as follows: Speed, Simple design, Strong support for non-linear development (thousands of parallel branches), Fully distributed, and Able to handle large projects like the Linux kernel efficiently (speed and data size) Since its birth in 2005, Git has evolved and matured to be easy to use and yet retain these initial qualities. It’s amazingly fast, it’s very efficient with large projects, and it has an incredible branching system for non-linear development. So what is the difference between Git and Git hub? Git is the repositories while GitHub is a place to store those repositories. litterally a hub for Git. </p>
        </div>

        <hr class="featurette-divider">

        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; 2018</p>
                </div>
            </div>
        </footer>
        

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>

</body>

</html>
